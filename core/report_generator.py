# core/report_generator.py - COMPLETE VERSION with REAL DATA ONLY, NO MOCK DATA

from django.contrib.auth.decorators import login_required
from django.http import HttpResponse, JsonResponse
from django.shortcuts import render
from django.utils import timezone
from django.db.models import Q, Count, Max
from datetime import datetime, timedelta
import io
from docx import Document
from docx.shared import Inches, Pt, RGBColor
from docx.enum.text import WD_ALIGN_PARAGRAPH, WD_PARAGRAPH_ALIGNMENT
from docx.enum.style import WD_STYLE_TYPE
from docx.enum.table import WD_TABLE_ALIGNMENT
from docx.oxml.shared import OxmlElement, qn

from accounts.models import CustomUser
from core.models import AuditLog
from accounts.decorators import role_required

# Import apps if they exist
try:
    from seniors.models import SeniorCitizen
    SENIORS_APP_AVAILABLE = True
except ImportError:
    SENIORS_APP_AVAILABLE = False

try:
    from verifications.models import VerificationRequest, DiscountTransaction
    VERIFICATIONS_APP_AVAILABLE = True
except ImportError:
    VERIFICATIONS_APP_AVAILABLE = False

def create_professional_document():
    """Create a professionally formatted Word document"""
    doc = Document()
    configure_document_styles(doc)
    return doc

def configure_document_styles(doc):
    """Configure professional styles for the document"""
    styles = doc.styles
    
    # Configure Normal style
    normal_style = styles['Normal']
    normal_font = normal_style.font
    normal_font.name = 'Calibri'
    normal_font.size = Pt(11)
    normal_font.color.rgb = RGBColor(0x40, 0x40, 0x40)
    
    # Configure Heading 1 style
    try:
        heading1_style = styles['Heading 1']
        heading1_font = heading1_style.font
        heading1_font.name = 'Calibri'
        heading1_font.size = Pt(16)
        heading1_font.bold = True
        heading1_font.color.rgb = RGBColor(0x1f, 0x4e, 0x79)
    except:
        pass
    
    # Configure Heading 2 style
    try:
        heading2_style = styles['Heading 2']
        heading2_font = heading2_style.font
        heading2_font.name = 'Calibri'
        heading2_font.size = Pt(14)
        heading2_font.bold = True
        heading2_font.color.rgb = RGBColor(0x2f, 0x5f, 0x8f)
    except:
        pass

def add_professional_header(doc, report_title, user_name, user_role):
    """Add a professional header to the document"""
    # Document title
    title = doc.add_heading(report_title, 0)
    title_para = title
    title_para.alignment = WD_ALIGN_PARAGRAPH.CENTER
    
    # Style the title
    for run in title.runs:
        run.font.name = 'Calibri'
        run.font.size = Pt(20)
        run.font.bold = True
        run.font.color.rgb = RGBColor(0x1f, 0x4e, 0x79)
    
    # Generation info
    info_para = doc.add_paragraph()
    info_para.alignment = WD_ALIGN_PARAGRAPH.CENTER
    
    # Generation date
    date_text = f'Generated on: {timezone.now().strftime("%B %d, %Y at %I:%M %p")}'
    date_run = info_para.add_run(date_text)
    date_run.font.name = 'Calibri'
    date_run.font.size = Pt(11)
    date_run.font.color.rgb = RGBColor(0x70, 0x70, 0x70)
    
    info_para.add_run('\n')
    
    # Generated by
    user_text = f'Generated by: {user_name} ({user_role})'
    user_run = info_para.add_run(user_text)
    user_run.font.name = 'Calibri'
    user_run.font.size = Pt(11)
    user_run.font.color.rgb = RGBColor(0x70, 0x70, 0x70)
    
    # Add separator line
    separator = doc.add_paragraph()
    separator.alignment = WD_ALIGN_PARAGRAPH.CENTER
    sep_run = separator.add_run('─' * 60)
    sep_run.font.color.rgb = RGBColor(0x1f, 0x4e, 0x79)
    
    # Add space
    doc.add_paragraph()

def create_professional_table(doc, headers, data, title=None):
    """Create a professionally styled table"""
    if title:
        title_para = doc.add_paragraph()
        title_run = title_para.add_run(title)
        title_run.font.bold = True
        title_run.font.size = Pt(12)
        title_run.font.color.rgb = RGBColor(0x1f, 0x4e, 0x79)
        title_para.space_after = Pt(6)
    
    # Create table
    table = doc.add_table(rows=1, cols=len(headers))
    table.style = 'Table Grid'
    table.alignment = WD_TABLE_ALIGNMENT.CENTER
    
    # Style header row
    header_cells = table.rows[0].cells
    for i, header in enumerate(headers):
        cell = header_cells[i]
        cell.text = str(header)
        
        # Style header cell
        for paragraph in cell.paragraphs:
            paragraph.alignment = WD_ALIGN_PARAGRAPH.CENTER
            for run in paragraph.runs:
                run.font.bold = True
                run.font.size = Pt(11)
                run.font.color.rgb = RGBColor(0xff, 0xff, 0xff)
        
        # Set header background
        set_cell_background_color(cell, RGBColor(0x1f, 0x4e, 0x79))
    
    # Add data rows
    for row_index, row_data in enumerate(data):
        row_cells = table.add_row().cells
        for i, cell_data in enumerate(row_data):
            cell = row_cells[i]
            cell.text = str(cell_data)
            
            # Style data cell
            for paragraph in cell.paragraphs:
                paragraph.alignment = WD_ALIGN_PARAGRAPH.CENTER
                for run in paragraph.runs:
                    run.font.size = Pt(10)
                    run.font.color.rgb = RGBColor(0x40, 0x40, 0x40)
            
            # Alternate row colors
            if row_index % 2 == 0:
                set_cell_background_color(cell, RGBColor(0xf8, 0xf9, 0xfa))
    
    # Add space after table
    space_para = doc.add_paragraph()
    space_para.space_after = Pt(12)
    
    return table

def set_cell_background_color(cell, color):
    """Set background color for a table cell"""
    try:
        cell_elem = cell._element
        cell_props = cell_elem.get_or_add_tcPr()
        shade_elem = OxmlElement('w:shd')
        shade_elem.set(qn('w:fill'), f'{color.r:02x}{color.g:02x}{color.b:02x}')
        cell_props.append(shade_elem)
    except:
        pass

def add_section_header(doc, section_title, section_number=None):
    """Add a professional section header"""
    if section_number:
        full_title = f"{section_number}. {section_title}"
    else:
        full_title = section_title
    
    heading = doc.add_heading(full_title, level=1)
    
    # Style the heading
    for run in heading.runs:
        run.font.name = 'Calibri'
        run.font.size = Pt(16)
        run.font.bold = True
        run.font.color.rgb = RGBColor(0x1f, 0x4e, 0x79)
    
    heading.space_after = Pt(6)
    return heading

def add_summary_box(doc, title, content_items):
    """Add a professional summary box"""
    # Create summary paragraph
    summary_para = doc.add_paragraph()
    
    # Title
    title_run = summary_para.add_run(title + '\n')
    title_run.font.bold = True
    title_run.font.size = Pt(12)
    title_run.font.color.rgb = RGBColor(0x1f, 0x4e, 0x79)
    
    # Content items
    for item in content_items:
        item_run = summary_para.add_run(f"• {item}\n")
        item_run.font.size = Pt(10)
        item_run.font.color.rgb = RGBColor(0x40, 0x40, 0x40)
    
    # Add spacing
    summary_para.space_after = Pt(12)

@login_required
@role_required('SA', 'AD', 'RA')
def generate_report(request):
    """Generate comprehensive system reports with professional formatting - REAL DATA ONLY"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Invalid request method'}, status=405)
    
    report_type = request.POST.get('report_type', 'comprehensive')
    
    try:
        # Create professionally formatted document
        doc = create_professional_document()
        
        # Determine report title
        report_titles = {
            'comprehensive': 'VeriSior Complete System Report',
            'senior_citizen_comprehensive': 'VeriSior Senior Citizens Report',
            'system_administration_comprehensive': 'VeriSior System Administration Report',
            'senior_citizen_list': 'VeriSior Senior Citizen List Report',
            'pending_approval': 'VeriSior Pending Approval Report',
            'id_validation': 'VeriSior Public Verification Report',
            'id_expiry_renewal': 'VeriSior ID Expiry & Renewal Report',
            'discount_application': 'VeriSior Discount Application Report',
            'role_based_user': 'VeriSior Role-based User Report',
            'failed_login': 'VeriSior Failed Login Report',
            'admin_activity': 'VeriSior Admin Activity Report',
            'system_uptime': 'VeriSior System Uptime Report',
            'validation_latency': 'VeriSior Validation Latency Report',
            'id_usage': 'VeriSior ID Usage Report'
        }
        
        report_title = report_titles.get(report_type, 'VeriSior System Report')
        user_name = request.user.get_full_name() or request.user.username
        user_role = request.user.get_role_display()
        
        # Add professional header
        add_professional_header(doc, report_title, user_name, user_role)
        
        # Generate specific reports based on type
        if report_type == 'comprehensive':
            generate_all_reports_professional(doc)
        elif report_type == 'senior_citizen_comprehensive':
            generate_senior_citizen_comprehensive_report_professional(doc)
        elif report_type == 'system_administration_comprehensive':
            generate_system_administration_comprehensive_report_professional(doc)
        elif report_type == 'senior_citizen_list':
            generate_senior_citizen_report(doc)
        elif report_type == 'pending_approval':
            generate_pending_approval_report(doc)
        elif report_type == 'id_validation':
            generate_id_validation_report(doc)
        elif report_type == 'id_expiry_renewal':
            generate_id_expiry_renewal_report(doc)
        elif report_type == 'discount_application':
            generate_discount_application_report(doc)
        elif report_type == 'role_based_user':
            generate_role_based_user_report(doc)
        elif report_type == 'failed_login':
            generate_failed_login_report(doc)
        elif report_type == 'admin_activity':
            generate_admin_activity_report(doc)
        elif report_type == 'system_uptime':
            generate_system_uptime_report(doc)
        elif report_type == 'validation_latency':
            generate_validation_latency_report(doc)
        elif report_type == 'id_usage':
            generate_id_usage_report(doc)
        else:
            return JsonResponse({'error': 'Invalid report type'}, status=400)
        
        # Save document to memory
        doc_io = io.BytesIO()
        doc.save(doc_io)
        doc_io.seek(0)
        
        # Create response
        response = HttpResponse(
            doc_io.getvalue(),
            content_type='application/vnd.openxmlformats-officedocument.wordprocessingml.document'
        )
        response['Content-Disposition'] = f'attachment; filename="{report_type}_report_{timezone.now().strftime("%Y%m%d_%H%M%S")}.docx"'
        
        # Log the report generation
        AuditLog.objects.create(
            user=request.user,
            action='READ',
            content_type='Report',
            description=f'Generated {report_type} report',
            ip_address=request.META.get('REMOTE_ADDR')
        )
        
        return response
        
    except Exception as e:
        return JsonResponse({'error': f'Error generating report: {str(e)}'}, status=500)

def generate_all_reports_professional(doc):
    """Generate comprehensive report with all sections - REAL DATA ONLY"""
    # Executive Summary
    add_summary_box(doc, "Executive Summary", [
        f"VeriSior Senior Citizen Management System Report",
        f"Generated on {timezone.now().strftime('%B %d, %Y')}",
        f"Total Users: {get_total_users()}",
        f"Active Users: {get_active_users_count()}",
        f"System Activity Logs: {get_total_audit_logs()}"
    ])
    
    # Generate all reports
    generate_senior_citizen_comprehensive_report_professional(doc)
    generate_system_administration_comprehensive_report_professional(doc)

def generate_senior_citizen_comprehensive_report_professional(doc):
    """Generate senior citizen report with REAL data only - NO MOCK DATA"""
    
    # Report overview
    add_summary_box(doc, "Report Overview", [
        "Complete overview of senior citizen management system",
        "Includes registrations, approvals, public verifications, and discount applications", 
        "Real-time data from VeriSior database"
    ])
    
    # 1. Senior Citizen Registration Statistics
    add_section_header(doc, "Senior Citizen Registration Statistics", 1)
    
    if SENIORS_APP_AVAILABLE:
        # REAL DATA ONLY
        total_seniors = SeniorCitizen.objects.count()
        active_seniors = SeniorCitizen.objects.filter(status='APPROVED').count()
        pending_seniors = SeniorCitizen.objects.filter(status='PENDING').count()
        archived_seniors = SeniorCitizen.objects.filter(status='ARCHIVED').count()
        # Count deceased seniors
        deceased_seniors = SeniorCitizen.objects.filter(
            status='ARCHIVED',
            archive_reason__icontains='deceased'
        ).count()
        # Recent registrations (last 30 days)
        recent_count = SeniorCitizen.objects.filter(
            created_at__gte=timezone.now() - timedelta(days=30)
        ).count()
        
        stats_data = [
            ('Total Senior Citizens Registered', total_seniors),
            ('Active/Approved Records', active_seniors),
            ('Pending Approval', pending_seniors),
            ('Archived Records', archived_seniors),
            ('Deceased Records', deceased_seniors),
            ('Recent Registrations (30 days)', recent_count),
        ]
        
        create_professional_table(doc, ['Category', 'Count'], stats_data, "Registration Summary")
        
    else:
        para = doc.add_paragraph("Senior Citizen module is not available in this system.")
        for run in para.runs:
            run.font.italic = True
            run.font.color.rgb = RGBColor(0x70, 0x70, 0x70)
    
    # 2. Approval Status
    add_section_header(doc, "Approval Status", 2)
    
    if SENIORS_APP_AVAILABLE:
        # REAL DATA ONLY
        pending_approvals = SeniorCitizen.objects.filter(status='PENDING').count()
        overdue_approvals = SeniorCitizen.objects.filter(
            status='PENDING',
            created_at__lt=timezone.now() - timedelta(days=7)
        ).count()
        monthly_approvals = SeniorCitizen.objects.filter(
            status='APPROVED',
            updated_at__gte=timezone.now() - timedelta(days=30)
        ).count()
        
        approval_data = [
            ('Total Pending Approvals', pending_approvals),
            ('Overdue (>7 days)', overdue_approvals),
            ('Approved This Month', monthly_approvals),
        ]
        
        create_professional_table(doc, ['Status', 'Count'], approval_data, "Approval Workflow Status")
    
    # 3. ID Renewals & Lifecycle Management
    add_section_header(doc, "ID Renewals & Lifecycle Management", 3)
    
    if SENIORS_APP_AVAILABLE:
        total_renewals = get_total_renewals()
        renewals_this_month = get_renewals_this_month()
        renewals_this_year = get_renewals_this_year()
        expired_ids = get_expired_ids()
        
        today = timezone.now().date()
        expiring_30_days = SeniorCitizen.objects.filter(
            status='APPROVED',
            expiration_date__gte=today,
            expiration_date__lte=today + timedelta(days=30)
        ).count()
        
        renewal_data = [
            ('Total ID Renewals Completed', total_renewals),
            ('Renewals This Month', renewals_this_month),
            ('Renewals This Year', renewals_this_year),
            ('Currently Expired IDs', expired_ids),
            ('Expiring within 30 days', expiring_30_days),
        ]
        
        create_professional_table(doc, ['Renewal Category', 'Count'], renewal_data, "ID Renewal Summary")
    
    # 4. Public Verification Portal Statistics
    add_section_header(doc, "Public Verification Portal Statistics", 4)
    
    # Get REAL verification data only
    verification_data = get_verification_statistics()
    
    verification_stats = [
        ('Total ID Verification Attempts', verification_data['total_verifications']),
        ('Successful Verifications', verification_data['successful_verifications']),
        ('Failed Verifications', verification_data['failed_verifications']),
        ('Verification Requests Sent', verification_data['verification_requests']),
        ('Verifications Today', verification_data['verifications_today']),
        ('Verifications This Month', verification_data['verifications_this_month']),
    ]
    
    create_professional_table(doc, ['Verification Metric', 'Count'], verification_stats, "Public Portal Usage")
    
    # 5. Discount Applications from Verification Portal
    add_section_header(doc, "Discount Applications", 5)
    
    discount_data = get_discount_application_statistics()
    
    discount_stats = [
        ('Total Discount Applications', discount_data['total_applications']),
        ('Cinema Discounts Applied', discount_data['cinema_discounts']),
        ('Restaurant Discounts Applied', discount_data['restaurant_discounts']),
        ('Grocery Discounts Applied', discount_data['grocery_discounts']),
        ('Pharmacy Discounts Applied', discount_data['pharmacy_discounts']),
        ('Applications Today', discount_data['applications_today']),
        ('Applications This Month', discount_data['applications_this_month']),
    ]
    
    create_professional_table(doc, ['Discount Category', 'Count'], discount_stats, "Discount Usage Summary")

def generate_system_administration_comprehensive_report_professional(doc):
    """Generate system administration report with REAL data only"""
    
    # Report overview
    add_summary_box(doc, "Report Overview", [
        "Administrative and security monitoring report",
        "User management and activity tracking",
        "System performance metrics",
        "Security analysis with real audit data"
    ])
    
    # 1. User Management by Role
    add_section_header(doc, "User Management by Role", 1)
    
    role_choices = getattr(CustomUser, 'ROLE_CHOICES', [
        ('RA', 'Root Administrator'),
        ('SA', 'System Administrator'), 
        ('AD', 'Administrator'),
        ('EM', 'Employee')
    ])
    
    user_data = []
    for role_code, role_display in role_choices:
        # REAL DATA ONLY
        active_count = CustomUser.objects.filter(role=role_code, is_active=True).count()
        total_count = CustomUser.objects.filter(role=role_code).count()
        user_data.append((role_display, active_count, total_count))
    
    create_professional_table(doc, ['Role', 'Active Users', 'Total Users'], user_data, "User Distribution by Role")
    
    # 2. Security Monitoring with REAL failed login data
    add_section_header(doc, "Security Monitoring", 2)
    
    # Get REAL failed login attempts from audit logs
    failed_logins = AuditLog.objects.filter(
        Q(action='LOGIN') & 
        (Q(description__icontains='failed') | 
         Q(description__icontains='invalid') |
         Q(description__icontains='incorrect') |
         Q(description__icontains='Failed') |
         Q(description__icontains='denied'))
    )
    
    today = timezone.now().date()
    # REAL DATA ONLY
    security_data = [
        ('Failed Logins Today', failed_logins.filter(timestamp__date=today).count()),
        ('Failed Logins This Week', failed_logins.filter(timestamp__gte=today - timedelta(days=7)).count()),
        ('Failed Logins This Month', failed_logins.filter(timestamp__gte=today - timedelta(days=30)).count()),
        ('Total Failed Login Attempts', failed_logins.count()),
    ]
    
    create_professional_table(doc, ['Security Metric', 'Count'], security_data, "Security Analysis Summary")
    
    # 2.1 Detailed Failed Login Attempts Table
    add_section_header(doc, "Failed Login Attempts Details", 2.1)
    
    # Get recent failed login attempts with details
    recent_failed_logins = failed_logins.order_by('-timestamp')[:20]  # Last 20 failed attempts
    
    if recent_failed_logins.exists():
        failed_login_data = []
        
        for log in recent_failed_logins:
            # Extract username from description if available
            username = "Unknown"
            if log.user:
                username = log.user.username
            elif 'username:' in log.description.lower():
                parts = log.description.lower().split('username:')
                if len(parts) > 1:
                    username = parts[1].strip().split()[0]
            elif 'for user' in log.description.lower():
                parts = log.description.lower().split('for user')
                if len(parts) > 1:
                    username = parts[1].strip().split()[0]
            elif 'user:' in log.description.lower():
                parts = log.description.lower().split('user:')
                if len(parts) > 1:
                    username = parts[1].strip().split()[0]
            
            # Get IP address and user agent
            ip_address = log.ip_address or "Unknown"
            device_info = log.user_agent[:50] + "..." if log.user_agent and len(log.user_agent) > 50 else (log.user_agent or "Unknown")
            
            # Get timestamp
            timestamp = log.timestamp.strftime("%m/%d/%Y %H:%M:%S")
            
            # Get description (truncated)
            description = log.description[:100] + "..." if len(log.description) > 100 else log.description
            
            failed_login_data.append([
                timestamp,
                username,
                ip_address,
                device_info,
                description
            ])
        
        create_professional_table(
            doc, 
            ['Timestamp', 'Username', 'IP Address', 'Device/Browser', 'Details'], 
            failed_login_data, 
            "Recent Failed Login Attempts (Last 20)"
        )
    else:
        para = doc.add_paragraph("No failed login attempts recorded.")
        for run in para.runs:
            run.font.italic = True
            run.font.color.rgb = RGBColor(0x70, 0x70, 0x70)
    
    # 2.2 Failed Login Summary by IP Address
    add_section_header(doc, "Failed Login Analysis by IP Address", 2.2)
    
    # Group failed logins by IP address
    ip_stats = failed_logins.values('ip_address').annotate(
        attempt_count=Count('id')
    ).order_by('-attempt_count')[:10]  # Top 10 IPs
    
    if ip_stats:
        ip_data = []
        for stat in ip_stats:
            ip_addr = stat['ip_address'] or 'Unknown'
            count = stat['attempt_count']
            
            # Get latest attempt for this IP
            latest_attempt = failed_logins.filter(
                ip_address=stat['ip_address']
            ).order_by('-timestamp').first()
            
            latest_time = latest_attempt.timestamp.strftime("%m/%d/%Y %H:%M") if latest_attempt else "Unknown"
            
            ip_data.append([ip_addr, count, latest_time])
        
        create_professional_table(
            doc, 
            ['IP Address', 'Failed Attempts', 'Latest Attempt'], 
            ip_data, 
            "Top IP Addresses by Failed Login Attempts"
        )
    
    # 3. Administrative Activity with REAL data
    add_section_header(doc, "Administrative Activity", 3)
    
    # Get REAL admin actions from audit logs
    admin_actions = AuditLog.objects.filter(
        user__role__in=['RA', 'SA', 'AD']
    ).select_related('user')
    
    # REAL DATA ONLY
    activity_data = [
        ('Create Actions', admin_actions.filter(action='CREATE').count()),
        ('Update Actions', admin_actions.filter(action='UPDATE').count()),
        ('Delete Actions', admin_actions.filter(action='DELETE').count()),
        ('Login Actions', admin_actions.filter(action='LOGIN').count()),
        ('Total Admin Actions', admin_actions.count()),
    ]
    
    create_professional_table(doc, ['Action Type', 'Count'], activity_data, "Administrative Action Summary")
    
    # 3.1 Administrative Actions by User
    add_section_header(doc, "Administrative Actions by User", 3.1)
    
    # Get admin activity summary by user
    admin_users = CustomUser.objects.filter(role__in=['RA', 'SA', 'AD'], is_active=True)
    admin_user_data = []
    
    for user in admin_users:
        user_actions = admin_actions.filter(user=user)
        total_actions = user_actions.count()
        
        if total_actions > 0:
            # Get action breakdown
            creates = user_actions.filter(action='CREATE').count()
            updates = user_actions.filter(action='UPDATE').count()
            deletes = user_actions.filter(action='DELETE').count()
            logins = user_actions.filter(action='LOGIN').count()
            
            # Get last activity
            last_action = user_actions.order_by('-timestamp').first()
            last_activity = last_action.timestamp.strftime("%m/%d/%Y %H:%M") if last_action else "Never"
            
            admin_user_data.append([
                user.username,
                user.get_role_display(),
                total_actions,
                creates,
                updates,
                deletes,
                logins,
                last_activity
            ])
    
    if admin_user_data:
        create_professional_table(
            doc, 
            ['Username', 'Role', 'Total Actions', 'Creates', 'Updates', 'Deletes', 'Logins', 'Last Activity'], 
            admin_user_data, 
            "Administrative Activity by User"
        )
    else:
        para = doc.add_paragraph("No administrative activity recorded.")
        for run in para.runs:
            run.font.italic = True
            run.font.color.rgb = RGBColor(0x70, 0x70, 0x70)
    
    # 4. System Performance Metrics
    add_section_header(doc, "System Performance Metrics", 4)
    
    performance_data = [
        ('Total System Actions Logged', get_total_audit_logs()),
        ('Activity in Last 24 Hours', AuditLog.objects.filter(timestamp__gte=timezone.now() - timedelta(hours=24)).count()),
        ('Total Users in System', get_total_users()),
        ('Active Users', get_active_users_count()),
        ('System Start Date', get_first_log_date()),
    ]
    
    create_professional_table(doc, ['Performance Metric', 'Value'], performance_data, "System Performance Overview")
    
    # 5. User Activity Details with REAL information
    add_section_header(doc, "User Activity Details", 5)
    
    # Get recent user activities with complete user information
    recent_activities = get_enhanced_recent_user_activities()
    
    if recent_activities:
        activity_headers = ['User', 'Role', 'Action', 'Target', 'Date/Time', 'IP Address']
        create_professional_table(doc, activity_headers, recent_activities, "Recent User Activities (Last 30 Days)")
    else:
        para = doc.add_paragraph("No recent user activities to display.")
        for run in para.runs:
            run.font.italic = True
            run.font.color.rgb = RGBColor(0x70, 0x70, 0x70)
    
    # 6. User Activity Summary by User
    add_section_header(doc, "User Activity Summary", 6)
    
    user_activity_summary = get_enhanced_user_activity_summary()
    
    if user_activity_summary:
        summary_headers = ['User', 'Role', 'Total Actions', 'Last Activity', 'Most Common Action', 'Last IP']
        create_professional_table(doc, summary_headers, user_activity_summary, "Activity Summary by User (Last 30 Days)")
    else:
        para = doc.add_paragraph("No user activity summary available.")
        for run in para.runs:
            run.font.italic = True
            run.font.color.rgb = RGBColor(0x70, 0x70, 0x70)

# Individual report functions for specific report types
def generate_senior_citizen_report(doc):
    """Senior Citizen List Report - REAL DATA ONLY"""
    add_summary_box(doc, "Report Overview", [
        "Complete list of all senior citizens in the system",
        "Includes active, archived records",
        "Registration and status information"
    ])
    
    add_section_header(doc, "Summary Statistics", 1)
    
    stats_data = [
        ('Total Senior Citizens', get_total_seniors()),
        ('Active Records', get_active_seniors()),
        ('Archived Records', get_archived_seniors()),
        ('Records This Month', get_seniors_this_month()),
        ('Records This Year', get_seniors_this_year()),
    ]
    
    create_professional_table(doc, ['Metric', 'Count'], stats_data, "Senior Citizen Summary")

def generate_pending_approval_report(doc):
    """Pending Approval Report - REAL DATA ONLY"""
    add_summary_box(doc, "Report Overview", [
        "Senior citizen registrations awaiting approval",
        "Approval processing times and status",
        "Administrative workflow information"
    ])
    
    add_section_header(doc, "Pending Approval Statistics", 1)
    
    pending_data = [
        ('Total Pending Approvals', get_pending_approvals()),
        ('Pending > 7 Days', get_pending_over_week()),
        ('Pending > 30 Days', get_pending_over_month()),
        ('Approvals This Week', get_approvals_this_week()),
        ('Rejections This Week', get_rejections_this_week()),
    ]
    
    create_professional_table(doc, ['Category', 'Count'], pending_data, "Approval Status")

def generate_id_validation_report(doc):
    """Public ID Verification Report - REAL DATA ONLY"""
    add_summary_box(doc, "Report Overview", [
        "Public verification portal usage by establishments",
        "ID verification attempts and outcomes",
        "Real verification data from database"
    ])
    
    add_section_header(doc, "Public Verification Statistics", 1)
    
    verification_stats = get_verification_statistics()
    
    validation_data = [
        ('Total Verification Attempts', verification_stats['total_verifications']),
        ('Successful Verifications', verification_stats['successful_verifications']),
        ('Failed Verifications', verification_stats['failed_verifications']),
        ('Verification Requests Sent', verification_stats['verification_requests']),
        ('Verifications Today', verification_stats['verifications_today']),
        ('Verifications This Month', verification_stats['verifications_this_month']),
    ]
    
    create_professional_table(doc, ['Verification Metric', 'Count'], validation_data, "Public Portal Usage Summary")

def generate_id_expiry_renewal_report(doc):
    """ID Expiry and Renewal Report - REAL DATA ONLY"""
    add_summary_box(doc, "Report Overview", [
        "Senior citizen IDs with expired or near-expiry dates",
        "Renewal management and tracking",
        "Real expiry data from database"
    ])
    
    add_section_header(doc, "Expiry and Renewal Statistics", 1)
    
    if SENIORS_APP_AVAILABLE:
        today = timezone.now().date()
        expired_ids = SeniorCitizen.objects.filter(
            status='APPROVED',
            expiration_date__lt=today
        ).count()
        
        expiring_30_days = SeniorCitizen.objects.filter(
            status='APPROVED',
            expiration_date__gte=today,
            expiration_date__lte=today + timedelta(days=30)
        ).count()
        
        expiring_60_days = SeniorCitizen.objects.filter(
            status='APPROVED',
            expiration_date__gte=today,
            expiration_date__lte=today + timedelta(days=60)
        ).count()
        
        renewals_this_month = SeniorCitizen.objects.filter(
            last_renewed_date__gte=today - timedelta(days=30)
        ).count()
        
        total_renewals = SeniorCitizen.objects.filter(
            last_renewed_date__isnull=False
        ).count()
    else:
        expired_ids = 0
        expiring_30_days = 0
        expiring_60_days = 0
        renewals_this_month = 0
        total_renewals = 0
    
    expiry_data = [
        ('Expired IDs', expired_ids),
        ('Expiring Within 30 Days', expiring_30_days),
        ('Expiring Within 60 Days', expiring_60_days),
        ('Renewals This Month', renewals_this_month),
        ('Total Renewals Completed', total_renewals),
    ]
    
    create_professional_table(doc, ['Category', 'Count'], expiry_data, "Renewal Status")

def generate_discount_application_report(doc):
    """Discount Application Report - REAL DATA ONLY"""
    add_summary_box(doc, "Report Overview", [
        "Discount applications processed through verification portal",
        "Real discount usage data from database",
        "Establishment usage patterns"
    ])
    
    add_section_header(doc, "Discount Application Statistics", 1)
    
    discount_stats = get_discount_application_statistics()
    
    discount_data = [
        ('Total Discount Applications', discount_stats['total_applications']),
        ('Cinema Discounts Applied', discount_stats['cinema_discounts']),
        ('Restaurant Discounts Applied', discount_stats['restaurant_discounts']),
        ('Grocery Discounts Applied', discount_stats['grocery_discounts']),
        ('Pharmacy Discounts Applied', discount_stats['pharmacy_discounts']),
        ('Applications Today', discount_stats['applications_today']),
        ('Applications This Month', discount_stats['applications_this_month']),
    ]
    
    create_professional_table(doc, ['Discount Category', 'Count'], discount_data, "Discount Application Summary")

def generate_role_based_user_report(doc):
    """Role-based User Report - REAL DATA ONLY"""
    add_summary_box(doc, "Report Overview", [
        "System users organized by role",
        "Real user data from database",
        "Account status and permissions"
    ])
    
    add_section_header(doc, "User Statistics by Role", 1)
    
    role_choices = getattr(CustomUser, 'ROLE_CHOICES', [
        ('RA', 'Root Administrator'),
        ('SA', 'System Administrator'), 
        ('AD', 'Administrator'),
        ('EM', 'Employee')
    ])
    
    user_data = []
    for role_code, role_display in role_choices:
        active_count = CustomUser.objects.filter(role=role_code, is_active=True).count()
        total_count = CustomUser.objects.filter(role=role_code).count()
        user_data.append((role_display, active_count, total_count))
    
    create_professional_table(doc, ['Role', 'Active Users', 'Total Users'], user_data, "User Distribution")

def generate_failed_login_report(doc):
    """Failed Login Report - REAL DATA ONLY"""
    add_summary_box(doc, "Report Overview", [
        "Security report tracking failed login attempts",
        "Real authentication data from audit logs",
        "Security monitoring and threat detection"
    ])
    
    add_section_header(doc, "Failed Login Statistics", 1)
    
    # Get REAL failed login attempts from audit logs
    failed_logins = AuditLog.objects.filter(
        Q(action='LOGIN') & 
        (Q(description__icontains='failed') | 
         Q(description__icontains='invalid') |
         Q(description__icontains='incorrect') |
         Q(description__icontains='Failed') |
         Q(description__icontains='denied'))
    )
    
    today = timezone.now().date()
    login_data = [
        ('Today', failed_logins.filter(timestamp__date=today).count()),
        ('This Week', failed_logins.filter(timestamp__gte=today - timedelta(days=7)).count()),
        ('This Month', failed_logins.filter(timestamp__gte=today - timedelta(days=30)).count()),
        ('Total', failed_logins.count()),
    ]
    
    create_professional_table(doc, ['Period', 'Failed Attempts'], login_data, "Failed Login Summary")

def generate_admin_activity_report(doc):
    """Admin Activity Report - REAL DATA ONLY"""
    add_summary_box(doc, "Report Overview", [
        "Administrative actions performed by system users",
        "Real activity data from audit logs",
        "System management and configuration changes"
    ])
    
    add_section_header(doc, "Administrative Activity Statistics", 1)
    
    admin_actions = AuditLog.objects.filter(user__role__in=['RA', 'SA', 'AD'])
    
    activity_data = [
        ('User Management Actions', admin_actions.filter(content_type='User').count()),
        ('System Configuration Changes', admin_actions.filter(content_type='SystemSettings').count()),
        ('Create Actions', admin_actions.filter(action='CREATE').count()),
        ('Update Actions', admin_actions.filter(action='UPDATE').count()),
        ('Delete Actions', admin_actions.filter(action='DELETE').count()),
    ]
    
    create_professional_table(doc, ['Action Type', 'Count'], activity_data, "Activity Summary")

def generate_system_uptime_report(doc):
    """System Uptime Report - REAL DATA ONLY"""
    add_summary_box(doc, "Report Overview", [
        "System availability and performance monitoring",
        "Real activity data showing system usage",
        "Performance analysis based on audit logs"
    ])
    
    add_section_header(doc, "System Activity Statistics", 1)
    
    uptime_data = [
        ('Total System Actions', get_total_audit_logs()),
        ('Activity Last 24 Hours', AuditLog.objects.filter(timestamp__gte=timezone.now() - timedelta(hours=24)).count()),
        ('Active Users This Month', get_monthly_active_users()),
        ('System Start Date', get_first_log_date()),
    ]
    
    create_professional_table(doc, ['Metric', 'Value'], uptime_data, "Performance Overview")

def generate_validation_latency_report(doc):
    """Validation Latency Report - REAL DATA ONLY"""
    add_summary_box(doc, "Report Overview", [
        "ID validation process analysis",
        "Real performance metrics from database",
        "System optimization insights"
    ])
    
    add_section_header(doc, "Validation Performance", 1)
    
    verification_stats = get_verification_statistics()
    discount_stats = get_discount_application_statistics()
    
    latency_data = [
        ('Total Verifications', verification_stats['total_verifications']),
        ('Verifications Today', verification_stats['verifications_today']),
        ('Successful Verifications', verification_stats['successful_verifications']),
        ('Total Discount Applications', discount_stats['total_applications']),
    ]
    
    create_professional_table(doc, ['Performance Metric', 'Value'], latency_data, "Latency Analysis")

def generate_id_usage_report(doc):
    """ID Usage Report - REAL DATA ONLY"""
    add_summary_box(doc, "Report Overview", [
        "Analysis of where senior citizen IDs are verified",
        "Real usage patterns by establishment and category",
        "Geographic distribution from database"
    ])
    
    add_section_header(doc, "ID Usage Statistics", 1)
    
    discount_stats = get_discount_application_statistics()
    
    usage_data = [
        ('Cinema Verifications', discount_stats['cinema_discounts']),
        ('Restaurant Verifications', discount_stats['restaurant_discounts']),
        ('Grocery Verifications', discount_stats['grocery_discounts']),
        ('Pharmacy Verifications', discount_stats['pharmacy_discounts']),
        ('Total Verifications', discount_stats['total_applications']),
        ('Unique Establishments', get_establishments_count()),
    ]
    
    create_professional_table(doc, ['Location/Category', 'Usage Count'], usage_data, "Usage Pattern Analysis")

# Helper functions that return REAL data only

def get_enhanced_recent_user_activities():
    """Get recent user activities with complete information including IP addresses"""
    thirty_days_ago = timezone.now() - timedelta(days=30)
    
    recent_logs = AuditLog.objects.filter(
        timestamp__gte=thirty_days_ago,
        user__isnull=False
    ).select_related('user').order_by('-timestamp')[:50]  # Get last 50 activities
    
    activities = []
    for log in recent_logs:
        if log.user:
            user_display = f"{log.user.first_name} {log.user.last_name}".strip() or log.user.username
            role_display = log.user.get_role_display() if hasattr(log.user, 'get_role_display') else 'Unknown'
        else:
            user_display = 'System/Unknown'
            role_display = 'N/A'
        
        action_display = log.get_action_display()
        target_display = f"{log.content_type}" + (f" (ID: {log.object_id})" if log.object_id else "")
        datetime_display = log.timestamp.strftime("%m/%d/%Y %H:%M")
        ip_address = log.ip_address or 'Unknown'
        
        activities.append([
            user_display,
            role_display,
            action_display,
            target_display,
            datetime_display,
            ip_address
        ])
    
    return activities

def get_enhanced_user_activity_summary():
    """Get activity summary by user with additional details"""
    thirty_days_ago = timezone.now() - timedelta(days=30)
    
    # Get users who have been active in the last 30 days
    active_users = CustomUser.objects.filter(
        audit_logs__timestamp__gte=thirty_days_ago
    ).distinct()
    
    user_summaries = []
    
    for user in active_users:
        user_logs = AuditLog.objects.filter(
            user=user,
            timestamp__gte=thirty_days_ago
        )
        
        total_actions = user_logs.count()
        last_activity = user_logs.order_by('-timestamp').first()
        
        # Get most common action
        most_common_action = user_logs.values('action').annotate(
            count=Count('action')
        ).order_by('-count').first()
        
        # Get last IP address
        last_ip = last_activity.ip_address if last_activity else 'Unknown'
        
        user_display = f"{user.first_name} {user.last_name}".strip() or user.username
        role_display = user.get_role_display() if hasattr(user, 'get_role_display') else 'Unknown'
        last_activity_display = last_activity.timestamp.strftime("%m/%d/%Y %H:%M") if last_activity else "Never"
        most_common_display = most_common_action['action'] if most_common_action else "None"
        
        user_summaries.append([
            user_display,
            role_display,
            str(total_actions),
            last_activity_display,
            most_common_display,
            last_ip or 'Unknown'
        ])
    
    # Sort by total actions (descending)
    user_summaries.sort(key=lambda x: int(x[2]), reverse=True)
    
    return user_summaries

# Helper functions for real data retrieval

def get_verification_statistics():
    """Get REAL verification statistics from verifications app"""
    if not VERIFICATIONS_APP_AVAILABLE:
        return {
            'total_verifications': 0,
            'successful_verifications': 0,
            'failed_verifications': 0,
            'verification_requests': 0,
            'verifications_today': 0,
            'verifications_this_month': 0,
        }
    
    try:
        today = timezone.now().date()
        this_month = timezone.now().replace(day=1).date()
        
        # REAL DATA from database
        total_verification_requests = VerificationRequest.objects.filter(is_archived=False).count()
        verification_requests_today = VerificationRequest.objects.filter(
            created_at__date=today,
            is_archived=False
        ).count()
        verification_requests_this_month = VerificationRequest.objects.filter(
            created_at__date__gte=this_month,
            is_archived=False
        ).count()
        
        # Successful verifications = discount transactions (only successful verifications can apply discounts)
        successful_verifications = DiscountTransaction.objects.filter(
            status='APPLIED'
        ).values('id_number').distinct().count()
        
        verifications_today = DiscountTransaction.objects.filter(
            created_at__date=today,
            status='APPLIED'
        ).values('id_number').distinct().count()
        
        verifications_this_month = DiscountTransaction.objects.filter(
            created_at__date__gte=this_month,
            status='APPLIED'
        ).values('id_number').distinct().count()
        
        total_verifications = successful_verifications + total_verification_requests
        
        return {
            'total_verifications': total_verifications,
            'successful_verifications': successful_verifications,
            'failed_verifications': total_verification_requests,
            'verification_requests': total_verification_requests,
            'verifications_today': verifications_today,
            'verifications_this_month': verifications_this_month,
        }
    except Exception as e:
        # Return zeros if there's any database error
        return {
            'total_verifications': 0,
            'successful_verifications': 0,
            'failed_verifications': 0,
            'verification_requests': 0,
            'verifications_today': 0,
            'verifications_this_month': 0,
        }

def get_discount_application_statistics():
    """Get REAL discount application statistics from verifications app"""
    if not VERIFICATIONS_APP_AVAILABLE:
        return {
            'total_applications': 0,
            'cinema_discounts': 0,
            'restaurant_discounts': 0,
            'grocery_discounts': 0,
            'pharmacy_discounts': 0,
            'applications_today': 0,
            'applications_this_month': 0,
        }
    
    try:
        today = timezone.now().date()
        this_month = timezone.now().replace(day=1).date()
        
        # REAL DATA from database
        all_transactions = DiscountTransaction.objects.filter(status='APPLIED')
        
        total_applications = all_transactions.count()
        
        # Count by REAL category data
        cinema_discounts = all_transactions.filter(category='OTHER').count()
        restaurant_discounts = all_transactions.filter(category='RESTAURANT').count()
        grocery_discounts = all_transactions.filter(category='GROCERY').count()
        pharmacy_discounts = all_transactions.filter(category='MEDICINE').count()
        
        applications_today = all_transactions.filter(
            created_at__date=today
        ).count()
        
        applications_this_month = all_transactions.filter(
            created_at__date__gte=this_month
        ).count()
        
        return {
            'total_applications': total_applications,
            'cinema_discounts': cinema_discounts,
            'restaurant_discounts': restaurant_discounts,
            'grocery_discounts': grocery_discounts,
            'pharmacy_discounts': pharmacy_discounts,
            'applications_today': applications_today,
            'applications_this_month': applications_this_month,
        }
    except Exception as e:
        # Return zeros if there's any database error
        return {
            'total_applications': 0,
            'cinema_discounts': 0,
            'restaurant_discounts': 0,
            'grocery_discounts': 0,
            'pharmacy_discounts': 0,
            'applications_today': 0,
            'applications_this_month': 0,
        }

# All helper functions return REAL data only
def get_total_users():
    """Get REAL total number of users"""
    return CustomUser.objects.count()

def get_active_users_count():
    """Get REAL count of active users"""
    return CustomUser.objects.filter(is_active=True).count()

def get_total_audit_logs():
    """Get REAL total number of audit log entries"""
    return AuditLog.objects.count()

def get_total_seniors():
    """Get REAL total senior citizens"""
    if SENIORS_APP_AVAILABLE:
        return SeniorCitizen.objects.count()
    return 0

def get_active_seniors():
    """Get REAL active senior citizens"""
    if SENIORS_APP_AVAILABLE:
        return SeniorCitizen.objects.filter(status='APPROVED').count()
    return 0

def get_archived_seniors():
    """Get REAL archived senior citizens"""
    if SENIORS_APP_AVAILABLE:
        return SeniorCitizen.objects.filter(status='ARCHIVED').count()
    return 0

def get_seniors_this_month():
    """Get REAL seniors registered this month"""
    if SENIORS_APP_AVAILABLE:
        return SeniorCitizen.objects.filter(
            created_at__gte=timezone.now() - timedelta(days=30)
        ).count()
    return 0

def get_seniors_this_year():
    """Get REAL seniors registered this year"""
    if SENIORS_APP_AVAILABLE:
        return SeniorCitizen.objects.filter(
            created_at__year=timezone.now().year
        ).count()
    return 0

def get_pending_approvals():
    """Get REAL pending approvals"""
    if SENIORS_APP_AVAILABLE:
        return SeniorCitizen.objects.filter(status='PENDING').count()
    return 0

def get_pending_over_week():
    """Get REAL pending approvals over a week old"""
    if SENIORS_APP_AVAILABLE:
        return SeniorCitizen.objects.filter(
            status='PENDING',
            created_at__lt=timezone.now() - timedelta(days=7)
        ).count()
    return 0

def get_pending_over_month():
    """Get REAL pending approvals over a month old"""
    if SENIORS_APP_AVAILABLE:
        return SeniorCitizen.objects.filter(
            status='PENDING',
            created_at__lt=timezone.now() - timedelta(days=30)
        ).count()
    return 0

def get_approvals_this_week():
    """Get REAL approvals this week"""
    if SENIORS_APP_AVAILABLE:
        return SeniorCitizen.objects.filter(
            status='APPROVED',
            updated_at__gte=timezone.now() - timedelta(days=7)
        ).count()
    return 0

def get_rejections_this_week():
    """Get REAL rejections this week"""
    if SENIORS_APP_AVAILABLE:
        return SeniorCitizen.objects.filter(
            status='REJECTED',
            updated_at__gte=timezone.now() - timedelta(days=7)
        ).count()
    return 0

def get_total_renewals():
    """Get REAL total number of ID renewals completed"""
    if SENIORS_APP_AVAILABLE:
        try:
            from seniors.models import RenewalLog
            return RenewalLog.objects.count()
        except ImportError:
            # If RenewalLog doesn't exist, count from SeniorCitizen records
            return SeniorCitizen.objects.filter(
                last_renewed_date__isnull=False
            ).count()
    return 0

def get_renewals_this_year():
    """Get REAL renewals completed this year"""
    if SENIORS_APP_AVAILABLE:
        try:
            from seniors.models import RenewalLog
            return RenewalLog.objects.filter(
                renewal_date__year=timezone.now().year
            ).count()
        except ImportError:
            return SeniorCitizen.objects.filter(
                last_renewed_date__year=timezone.now().year
            ).count()
    return 0

def get_renewals_this_month():
    """Get REAL renewals this month"""
    if SENIORS_APP_AVAILABLE:
        return SeniorCitizen.objects.filter(
            last_renewed_date__gte=timezone.now().date() - timedelta(days=30)
        ).count()
    return 0

def get_expired_ids():
    """Get REAL count of expired IDs"""
    if SENIORS_APP_AVAILABLE:
        return SeniorCitizen.objects.filter(
            status='APPROVED',
            expiration_date__lt=timezone.now().date()
        ).count()
    return 0

def get_current_uptime():
    """Calculate REAL uptime based on first log"""
    first_log = AuditLog.objects.order_by('timestamp').first()
    if first_log:
        delta = timezone.now() - first_log.timestamp
        days = delta.days
        hours = delta.seconds // 3600
        return f"{days} days, {hours} hours"
    return "Unknown"

def get_monthly_active_users():
    """Get REAL count of users who have been active this month"""
    thirty_days_ago = timezone.now() - timedelta(days=30)
    active_user_ids = AuditLog.objects.filter(
        timestamp__gte=thirty_days_ago,
        user__isnull=False
    ).values_list('user_id', flat=True).distinct()
    return len(set(active_user_ids))

def get_first_log_date():
    """Get REAL date of the first audit log"""
    first_log = AuditLog.objects.order_by('timestamp').first()
    if first_log:
        return first_log.timestamp.strftime("%B %d, %Y")
    return "No logs available"

def get_establishments_count():
    """Get REAL count of unique establishments using the system"""
    if not VERIFICATIONS_APP_AVAILABLE:
        return 0
    
    try:
        # Count unique IP addresses as proxy for establishments
        establishments = DiscountTransaction.objects.filter(
            status='APPLIED',
            ip_address__isnull=False
        ).values('ip_address').distinct().count()
        
        return establishments
        
    except Exception:
        return 0
